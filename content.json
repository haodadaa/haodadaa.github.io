{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Haodada","url":"http://haodadaa.github.io"},"pages":[{"title":"分类","date":"2017-05-19T19:12:09.444Z","updated":"2017-05-19T19:12:09.444Z","comments":true,"path":"categories/index.html","permalink":"http://haodadaa.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2016-09-10T18:47:30.000Z","updated":"2017-05-19T19:17:58.171Z","comments":true,"path":"about/index.html","permalink":"http://haodadaa.github.io/about/index.html","excerpt":"","text":"本站点是基于hexo开发的静态网站，纯属个人兴趣、技术分享，转载网站内容请注明出处。作者从事Android开发，同时也是一个Geek兴趣爱好者，欢迎大家浏览本站点，希望能多和大神们交流。"},{"title":"标签","date":"2017-05-19T19:12:01.281Z","updated":"2017-05-19T19:12:01.281Z","comments":false,"path":"tags/index.html","permalink":"http://haodadaa.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"RxJava2.0 操作符简介","slug":"RxJava操作符简介","date":"2017-05-19T17:51:02.622Z","updated":"2017-05-19T18:42:29.857Z","comments":true,"path":"2017/05/20/RxJava操作符简介/","link":"","permalink":"http://haodadaa.github.io/2017/05/20/RxJava操作符简介/","excerpt":"just操作符just()，直接创建一个Observable并自动调用onNext()发射数据 1Observable&lt;String&gt; observable = Observable.just(\"Hello World\"); fromIterable操作符fromIterable()，遍历集合，然后发射每一个item，相当于多次调用onNext()，每次传一个item 12345List&lt;String&gt; list = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 10; i++) &#123; list.add(i + \"\");&#125;Observable&lt;String&gt; observable = Observable.fromIterable((Iterable&lt;String&gt;) list);","text":"just操作符just()，直接创建一个Observable并自动调用onNext()发射数据 1Observable&lt;String&gt; observable = Observable.just(\"Hello World\"); fromIterable操作符fromIterable()，遍历集合，然后发射每一个item，相当于多次调用onNext()，每次传一个item 12345List&lt;String&gt; list = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 10; i++) &#123; list.add(i + \"\");&#125;Observable&lt;String&gt; observable = Observable.fromIterable((Iterable&lt;String&gt;) list); defer操作符defer()，当观察者订阅时，才创建Observable，并且针对每个观察者创建都是一个新的Observable。以何种方式创建这个Observable对象，当满足回调条件后，就会进行相应的回调。 123456Observable&lt;String&gt; observable = Observable.defer(new Callable&lt;ObservableSource&lt;? extends String&gt;&gt;() &#123; @Override public ObservableSource&lt;? extends String&gt; call() throws Exception &#123; return Observable.just(\"hello\"); &#125;&#125;); interval操作符interval()，创建一个按固定时间间隔发射整数序列的Observable，即按照固定秒数一次调用onNext(),可用作定时器 1Observable&lt;Long&gt; observable = Observable.interval(1, TimeUnit.SECONDS); range操作符range()，创建一个发射整数序列的Observable，第一个参数为起始值，第二个参数为发送个数，0则不发送，负数则抛出异常。 1Observable&lt;Integer&gt; observable = Observable.range(1, 10); timer操作符timer()，给定一个延迟时间间隔发射数据 1Observable&lt;Long&gt; observable = Observable.timer(2,TimeUnit.SECONDS); repeat操作符repeat()，重复调用一个Observable事件 1Observable&lt;String&gt; observable = Observable.just(\"1\").repeat(); map操作符map()，把原来的Observable对象转换为另一个Observable对象，对传输的数据进行灵活操作，获取想要的数据形式 123456Observable&lt;Integer&gt; observable = Observable.just(\"hello\").map(new Function&lt;String, Integer&gt;() &#123; @Override public Integer apply(String s) throws Exception &#123; return s.length(); &#125;&#125;); flatMap操作符 filter操作符 take操作符 doOnNext操作符","categories":[],"tags":[],"keywords":[]},{"title":"Gradle项目依赖统一管理","slug":"Gradle项目依赖统一管理","date":"2017-05-19T17:51:02.619Z","updated":"2017-05-19T18:38:48.699Z","comments":true,"path":"2017/05/20/Gradle项目依赖统一管理/","link":"","permalink":"http://haodadaa.github.io/2017/05/20/Gradle项目依赖统一管理/","excerpt":"前言 通常情况下，我们只有一application module时，只需要配置一个project级的build.gradle和一个module级的build.gradle。 当我们一个项目下有多个module并且依赖也比较复杂时，如果这时需要修改某个开源库的版本依赖，则需要找到每个引用依赖的地方进行修改。 如果我们自定义一个配置文件统一的管理这些依赖，不仅方便我们修改还减少错误率。","text":"前言 通常情况下，我们只有一application module时，只需要配置一个project级的build.gradle和一个module级的build.gradle。 当我们一个项目下有多个module并且依赖也比较复杂时，如果这时需要修改某个开源库的版本依赖，则需要找到每个引用依赖的地方进行修改。 如果我们自定义一个配置文件统一的管理这些依赖，不仅方便我们修改还减少错误率。 解决方案 在root目录声明全局变量，在project级build.gradle中apply from引用进来，使用rootProject.ext引用具体的库依赖 步骤 在项目的根文件夹下新建一个config.gradle（名字可以自己定义)声明全局变量，内容如下(请根据自己库和版本进行修改)： 1234567891011121314151617181920212223242526272829303132333435363738def supportVersion = \"25.0.1\"def retrofitVersion = \"2.0.2\"def butterKnifeVersion = \"8.1.0\"project.ext &#123; android = [ compileSdkVersion: 25, buildToolsVersion: \"25.0.1\", applicationId : \"com.hao.mybaselib\", minSdkVersion : 16, targetSdkVersion : 25, versionCode : 1, versionName : \"1.0\", javaVersion : JavaVersion.VERSION_1_8 ] dependencies = [ //android-support \"support-v4\" : \"com.android.support:support-v4:$&#123;supportVersion&#125;\", \"appcompat-v7\" : \"com.android.support:appcompat-v7:$&#123;supportVersion&#125;\", \"design\" : \"com.android.support:design:$&#123;supportVersion&#125;\", \"recyclerview\" : \"com.android.support:recyclerview-v7:$&#123;supportVersion&#125;\", \"cardview\" : \"com.android.support:cardview-v7:$&#123;supportVersion&#125;\", //rx \"rxjava\" : \"io.reactivex:rxjava:1.1.6\", \"rxandroid\" : \"io.reactivex:rxandroid:1.2.1\", //retrofit \"retrofit\" : \"com.squareup.retrofit2:retrofit:$&#123;retrofitVersion&#125;\", \"adapter-rxjava\": \"com.squareup.retrofit2:adapter-rxjava:$&#123;retrofitVersion&#125;\", //others \"okhttp3-logging-interceptor\": \"com.squareup.okhttp3:logging-interceptor:3.1.2\", \"butterknife\" : \"com.jakewharton:butterknife:$&#123;butterKnifeVersion&#125;\", \"butterknife-compiler\" : \"com.jakewharton:butterknife-compiler:$&#123;butterKnifeVersion&#125;\", ]&#125; 在项目级的build.gradle添加apply from引用 1apply from: \"config.gradle\" 在module级的build.gradle中使用如下： 1234567891011121314151617181920212223242526272829303132333435apply plugin: 'com.android.library'apply plugin: 'com.neenbedankt.android-apt'android &#123; compileSdkVersion rootProject.ext.android.compileSdkVersion buildToolsVersion rootProject.ext.android.buildToolsVersion defaultConfig &#123;// applicationId \"com.hao.mybaselib\" minSdkVersion rootProject.ext.android.minSdkVersion targetSdkVersion rootProject.ext.android.targetSdkVersion versionCode rootProject.ext.android.versionCode versionName rootProject.ext.android.versionName &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125;dependencies &#123; compile fileTree(include: ['*.jar'], dir: 'libs') testCompile 'junit:junit:4.12' compile rootProject.ext.dependencies.getAt(\"appcompat-v7\") compile rootProject.ext.dependencies.getAt(\"recyclerview\") //ButterKnife compile rootProject.ext.dependencies.getAt(\"butterknife\") apt rootProject.ext.dependencies.getAt(\"butterknife-compiler\") //rx compile rootProject.ext.dependencies.getAt(\"rxjava\") compile rootProject.ext.dependencies.getAt(\"rxandroid\")&#125; 之后若需要修改版本或配置，只需要在config.gradle中做修改。","categories":[],"tags":[],"keywords":[]},{"title":"Android 6.0运行时权限","slug":"Android-6.0运行时权限","date":"2017-05-19T07:44:18.000Z","updated":"2017-05-19T18:38:41.126Z","comments":true,"path":"2017/05/19/Android-6.0运行时权限/","link":"","permalink":"http://haodadaa.github.io/2017/05/19/Android-6.0运行时权限/","excerpt":"前言Android6.0的发布也证明了Google开始在安全和权限的控制，以及给用户更人性化的方式去使用Android系统。6.0带来了一个主要的新特性：运行时权限。在以前的版本，我们只需要在mainfest文件中声明所需要的权限，及可获得整个应用程序使用过程中的权限，这些权限在我们安装应用程序时会列出。而运行时权限则是当我们需要使用某个敏感权限时，弹出一个对话框，让用户去选择是否同意授权，这样一定程度上保护了用户的隐私安全，这个处理权完全在用户手上。","text":"前言Android6.0的发布也证明了Google开始在安全和权限的控制，以及给用户更人性化的方式去使用Android系统。6.0带来了一个主要的新特性：运行时权限。在以前的版本，我们只需要在mainfest文件中声明所需要的权限，及可获得整个应用程序使用过程中的权限，这些权限在我们安装应用程序时会列出。而运行时权限则是当我们需要使用某个敏感权限时，弹出一个对话框，让用户去选择是否同意授权，这样一定程度上保护了用户的隐私安全，这个处理权完全在用户手上。 分类并非所有的权限都是需要用户同意的，不然用户需要授权的权限太多也影响了用户体验，而且并非所有的权限都是敏感权限。因此Android6.0对权限进行了分类，分类如下： Normal Permissions 正常权限不涉及用户隐私，不会带来用户安全问题；安装时就授权，不会在提示用户授权。这类权限应用程序需要时，只需在mainfest文件中声明。主要包括：1234567891011121314151617181920212223242526272829303132333435363738android.permission.ACCESS_LOCATION_EXTRA_COMMANDSandroid.permission.ACCESS_NETWORK_STATEandroid.permission.ACCESS_NOTIFICATION_POLICYandroid.permission.ACCESS_WIFI_STATEandroid.permission.ACCESS_WIMAX_STATEandroid.permission.BLUETOOTHandroid.permission.BLUETOOTH_ADMINandroid.permission.BROADCAST_STICKYandroid.permission.CHANGE_NETWORK_STATEandroid.permission.CHANGE_WIFI_MULTICAST_STATEandroid.permission.CHANGE_WIFI_STATEandroid.permission.CHANGE_WIMAX_STATEandroid.permission.DISABLE_KEYGUARDandroid.permission.EXPAND_STATUS_BARandroid.permission.FLASHLIGHTandroid.permission.GET_ACCOUNTSandroid.permission.GET_PACKAGE_SIZEandroid.permission.INTERNETandroid.permission.KILL_BACKGROUND_PROCESSESandroid.permission.MODIFY_AUDIO_SETTINGSandroid.permission.NFCandroid.permission.READ_SYNC_SETTINGSandroid.permission.READ_SYNC_STATSandroid.permission.RECEIVE_BOOT_COMPLETEDandroid.permission.REORDER_TASKSandroid.permission.REQUEST_INSTALL_PACKAGESandroid.permission.SET_TIME_ZONEandroid.permission.SET_WALLPAPERandroid.permission.SET_WALLPAPER_HINTSandroid.permission.SUBSCRIBED_FEEDS_READandroid.permission.TRANSMIT_IRandroid.permission.USE_FINGERPRINTandroid.permission.VIBRATEandroid.permission.WAKE_LOCKandroid.permission.WRITE_SYNC_SETTINGScom.android.alarm.permission.SET_ALARMcom.android.launcher.permission.INSTALL_SHORTCUTcom.android.launcher.permission.UNINSTALL_SHORTCUT Particular Permissions特殊权限特殊权限有两个：SYSTEM_ALERT_WINDOW，设置悬浮窗，进行一些黑科技WRITE_SETTINGS 修改系统设置这两个特殊权限需要通过Intent隐式启动的方式来授权，通过startActivityForResult来完成授权和获取授权结果。 Dangerous Permissions 危险权限危险权限即我们本文主要要说明的运行时权限，以下权限需要在运行时判断： 身体传感器BodySensor 日历Calendar 摄像头Camera 通讯录Contacts 地理位置Location 麦克风MicroPhone 电话Phone 短信SMS 存储空间Storage 权限分组和其具体权限，如下：12345678910111213141516171819202122232425262728293031323334353637383940414243//身体传感器group:android.permission-group.SENSORS permission:android.permission.BODY_SENSORS//日历group:android.permission-group.CALENDAR permission:android.permission.READ_CALENDAR permission:android.permission.WRITE_CALENDAR//摄像头group:android.permission-group.CAMERA permission:android.permission.CAMERA//通讯录group:android.permission-group.CONTACTS permission:android.permission.WRITE_CONTACTS permission:android.permission.GET_ACCOUNTS permission:android.permission.READ_CONTACTS//地理位置group:android.permission-group.LOCATION permission:android.permission.ACCESS_FINE_LOCATION permission:android.permission.ACCESS_COARSE_LOCATION//麦克风group:android.permission-group.MICROPHONE permission:android.permission.RECORD_AUDIO//电话group:android.permission-group.PHONE permission:android.permission.READ_CALL_LOG permission:android.permission.READ_PHONE_STATE permission:android.permission.CALL_PHONE permission:android.permission.WRITE_CALL_LOG permission:android.permission.USE_SIP permission:android.permission.PROCESS_OUTGOING_CALLS permission:com.android.voicemail.permission.ADD_VOICEMAIL//短信group:android.permission-group.SMS permission:android.permission.READ_SMS permission:android.permission.RECEIVE_WAP_PUSH permission:android.permission.RECEIVE_MMS permission:android.permission.RECEIVE_SMS permission:android.permission.SEND_SMS permission:android.permission.READ_CELL_BROADCASTS//存储空间group:android.permission-group.STORAGE permission:android.permission.READ_EXTERNAL_STORAGE permission:android.permission.WRITE_EXTERNAL_STORAGE 后续补上具体操作和代码。","categories":[],"tags":[],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2016-09-02T07:02:46.800Z","updated":"2017-05-19T18:37:37.907Z","comments":true,"path":"2016/09/02/hello-world/","link":"","permalink":"http://haodadaa.github.io/2016/09/02/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" #标题一 More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}